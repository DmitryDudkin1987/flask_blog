<!DOCTYPE html>
<html>
<head>
    <title>Внесение событий - Батч #{{ batch.id }}</title>
    <meta charset="utf-8">
    <style>
        body {
            margin: 20px;
            background: white;
            font-family: Arial;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ccc;
        }
        .logout {
            color: #dc3545;
            border: 1px solid #dc3545;
            background: transparent;
            padding: 8px 15px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 400;
            line-height: 1.5;
            transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out;
        }
        .logout:hover {
            background: #dc3545;
            color: white;
            text-decoration: none;
        }
        .back-link {
            color: #007bff;
            text-decoration: none;
            margin-right: 20px;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        .batch-info {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .batch-info h3 {
            margin-top: 0;
            color: #333;
        }
        .batch-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .info-item {
            padding: 5px 0;
        }
        .info-label {
            font-weight: bold;
            color: #666;
        }
        .form-container {
            max-width: 600px;
            margin: 30px auto;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background: #f9f9f9;
        }
        .form-container h3 {
            margin-top: 0;
            color: #333;
        }
        .form-container input,
        .form-container select {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box;
        }
        .form-container .save-btn {
            width: 100%;
            padding: 10px;
            border: none;
            background: #0d6efd;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 16px;
            font-weight: 400;
            line-height: 1.5;
            margin-top: 10px;
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out;
        }
        .form-container .save-btn:hover {
            background: #0b5ed7;
        }
        .events-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 30px;
        }
        .events-table th,
        .events-table td {
            padding: 10px;
            border: 1px solid #ccc;
            text-align: left;
        }
        .events-table th {
            background: #f5f5f5;
            font-weight: bold;
            cursor: pointer;
            position: relative;
        }
        .events-table th:hover {
            background: #e9e9e9;
        }
        .events-table th.sortable::after {
            content: "↕";
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: #999;
            font-size: 12px;
        }
        .events-table th.sorted-asc::after {
            content: "↑";
            color: #007bff;
        }
        .events-table th.sorted-desc::after {
            content: "↓";
            color: #007bff;
        }
        .events-table tr:hover {
            background: #f9f9f9;
        }
        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
        }
        .delete-btn:hover {
            background: #c82333;
        }
        .message {
            margin-top: 10px;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            display: none;
            border-radius: 3px;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .time-group-badge {
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: bold;
        }
        .planned-pause {
            background: #ffc107;
            color: #212529;
        }
        .utilization {
            background: #28a745;
            color: white;
        }
        .breakdown {
            background: #dc3545;
            color: white;
        }
        .overlapping-event {
            background-color: #ffebee !important;
            border-left: 3px solid #dc3545;
        }
        /* Скрытые поля для передачи данных из шаблона в JavaScript */
        .hidden-data {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Скрытые поля для передачи данных из шаблона в JavaScript -->
    <div class="hidden-data">
        <span id="batchStartTime">{{ batch.start_time }}</span>
        <span id="batchEndTime">{{ batch.end_time }}</span>
    </div>

    <div class="header">
        <div>
            <a href="/home" class="back-link">← На главную</a>
            <span>Пользователь: <strong>{{ username }}</strong></span>
        </div>
        <a href="{{ url_for('logout') }}" class="logout">Выйти</a>
    </div>

    <div class="batch-info">
        <h3>Информация о производственном батче</h3>
        <div class="batch-info-grid">
            <div class="info-item">
                <span class="info-label">ID батча:</span> {{ batch.id }}
            </div>
            <div class="info-item">
                <span class="info-label">Название детали:</span> {{ batch.part_name }}
            </div>
            <div class="info-item">
                <span class="info-label">Планируемое количество:</span> {{ batch.planned_quantity }}
            </div>
            <div class="info-item">
                <span class="info-label">Номер станка:</span> {{ batch.machine_number }}
            </div>
            <div class="info-item">
                <span class="info-label">Планируемое время начала:</span> {{ batch.start_time }}
            </div>
            <div class="info-item">
                <span class="info-label">Планируемое время окончания:</span> {{ batch.end_time }}
            </div>
        </div>
    </div>

    <div class="form-container">
        <h3>Внести новое событие</h3>
        <input type="hidden" id="batchId" value="{{ batch.id }}">
        
        <input type="text" id="eventName" placeholder="Название события" required>
        
        <input type="datetime-local" id="actualStartTime" placeholder="Фактическое время начала" required>
        <input type="datetime-local" id="actualEndTime" placeholder="Фактическое время окончания" required>
        
        <select id="timeGroup" required>
            <option value="">Выберите группу времени</option>
            <option value="Planned pause time">Planned pause time</option>
            <option value="Utilization hours">Utilization hours</option>
            <option value="Breakdown time">Breakdown time</option>
        </select>
        
        <button class="save-btn" onclick="saveEvent()">Сохранить событие</button>
        
        <div id="message" class="message"></div>
    </div>

    <div id="eventsContainer">
        <h3>Существующие события для батча #{{ batch.id }}</h3>
        <table class="events-table" id="eventsTable">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Название события</th>
                    <th class="sortable" id="sortStartTime" data-sort="start" data-direction="asc">Время начала</th>
                    <th>Время окончания</th>
                    <th>Группа времени</th>
                    <th>Действия</th>
                </tr>
            </thead>
            <tbody id="eventsBody">
                {% for event in events %}
                <tr id="event-{{ event.event_id }}">
                    <td>{{ event.event_id }}</td>
                    <td>{{ event.event_name }}</td>
                    <td data-sort-value="{{ event.actual_start_time }}">{{ event.actual_start_time }}</td>
                    <td>{{ event.actual_end_time }}</td>
                    <td>
                        <span class="time-group-badge 
                            {% if event.time_group == 'Planned pause time' %}planned-pause
                            {% elif event.time_group == 'Utilization hours' %}utilization
                            {% elif event.time_group == 'Breakdown time' %}breakdown{% endif %}">
                            {{ event.time_group }}
                        </span>
                    </td>
                    <td>
                        <button class="delete-btn" onclick="deleteEvent({{ event.event_id }})">Удалить</button>
                    </td>
                </tr>
                {% endfor %}
                {% if not events %}
                <tr>
                    <td colspan="6" style="text-align: center; color: #999; padding: 20px;">
                        Нет событий для этого батча
                    </td>
                </tr>
                {% endif %}
            </tbody>
        </table>
    </div>

    <script>
        // Глобальные переменные для сортировки
        let currentSortColumn = 'start';
        let currentSortDirection = 'asc';
        let eventsData = []; // Массив для хранения данных событий
        
        // Получаем плановое время начала и окончания батча из скрытых полей
        let batchStartTime = null;
        let batchEndTime = null;
        let minAllowedTime = null;
        let maxAllowedTime = null;

        // Функция преобразования строки времени из таблицы в объект Date
        function parseTableTime(timeString) {
            // Преобразуем формат "2024-01-01 10:00:00" в "2024-01-01T10:00:00"
            return new Date(timeString.replace(' ', 'T'));
        }
        
        // Инициализация временных границ батча
        function initBatchTimeBounds() {
            try {
                const startTimeStr = document.getElementById('batchStartTime').textContent;
                const endTimeStr = document.getElementById('batchEndTime').textContent;
                
                batchStartTime = parseTableTime(startTimeStr);
                batchEndTime = parseTableTime(endTimeStr);
                
                // Вычисляем допустимые границы: 3 часа до планового начала и 3 часа после планового окончания
                minAllowedTime = new Date(batchStartTime.getTime() - (3 * 60 * 60 * 1000));
                maxAllowedTime = new Date(batchEndTime.getTime() + (3 * 60 * 60 * 1000));
                
                console.log('Плановое время батча:', batchStartTime, 'до', batchEndTime);
                console.log('Допустимые границы для событий:', minAllowedTime, 'до', maxAllowedTime);
            } catch (error) {
                console.error('Ошибка при инициализации временных границ батча:', error);
                showMessage('Ошибка при загрузке данных о времени батча', 'error');
            }
        }
        
        // Функция проверки времени события относительно планового времени батча
        function checkEventTimeBounds(startTime, endTime) {
            if (!minAllowedTime || !maxAllowedTime) {
                console.error('Временные границы батча не инициализированы');
                return {
                    isValid: false,
                    message: 'Ошибка: временные границы батча не загружены'
                };
            }
            
            // Проверяем, что время события находится в пределах ±3 часа от планового времени батча
            if (startTime < minAllowedTime) {
                const diffHours = (minAllowedTime.getTime() - startTime.getTime()) / (1000 * 60 * 60);
                return {
                    isValid: false,
                    message: `Время начала события слишком раннее. Допустимое начало: не ранее ${formatDateTimeForMessage(minAllowedTime)} (на ${diffHours.toFixed(1)} часа раньше, чем разрешено)`
                };
            }
            
            if (endTime > maxAllowedTime) {
                const diffHours = (endTime.getTime() - maxAllowedTime.getTime()) / (1000 * 60 * 60);
                return {
                    isValid: false,
                    message: `Время окончания события слишком позднее. Допустимое окончание: не позднее ${formatDateTimeForMessage(maxAllowedTime)} (на ${diffHours.toFixed(1)} часа позже, чем разрешено)`
                };
            }
            
            // Дополнительная проверка: время события должно быть в пределах самого батча?
            // По условию требуется только проверка ±3 часа, но можно добавить и эту проверку
            if (startTime > batchEndTime) {
                const diffHours = (startTime.getTime() - batchEndTime.getTime()) / (1000 * 60 * 60);
                if (diffHours > 3) {
                    return {
                        isValid: false,
                        message: `Время начала события значительно позже планового окончания батча (на ${diffHours.toFixed(1)} часов)`
                    };
                }
            }
            
            if (endTime < batchStartTime) {
                const diffHours = (batchStartTime.getTime() - endTime.getTime()) / (1000 * 60 * 60);
                if (diffHours > 3) {
                    return {
                        isValid: false,
                        message: `Время окончания события значительно раньше планового начала батча (на ${diffHours.toFixed(1)} часов)`
                    };
                }
            }
            
            return {
                isValid: true,
                message: 'Время события в допустимых пределах'
            };
        }
        
        // Форматирование даты для сообщения
        function formatDateTimeForMessage(date) {
            if (!date) return 'не указано';
            
            // Форматируем дату в удобочитаемый вид
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            
            return `${day}.${month}.${year} ${hours}:${minutes}`;
        }
        
        // Функция проверки пересечения временных интервалов
        function checkTimeOverlap(newStart, newEnd) {
            const rows = document.querySelectorAll('#eventsBody tr[id^="event-"]');
            
            for (let row of rows) {
                const cells = row.querySelectorAll('td');
                // Время начала в 3-й колонке (индекс 2), окончания в 4-й (индекс 3)
                const existingStart = parseTableTime(cells[2].textContent);
                const existingEnd = parseTableTime(cells[3].textContent);
                
                // Проверяем пересечение интервалов (исключаем граничные совпадения)
                if (newStart < existingEnd && newEnd > existingStart) {
                    return {
                        hasOverlap: true,
                        overlappingEventId: row.id.replace('event-', ''),
                        overlappingEventName: cells[1].textContent
                    };
                }
            }
            return { hasOverlap: false };
        }
        
        // Функция для подсветки пересекающихся событий
        function highlightOverlappingEvents(newStart, newEnd) {
            const rows = document.querySelectorAll('#eventsBody tr[id^="event-"]');
            
            rows.forEach(row => {
                row.classList.remove('overlapping-event');
                
                const cells = row.querySelectorAll('td');
                const existingStart = parseTableTime(cells[2].textContent);
                const existingEnd = parseTableTime(cells[3].textContent);
                
                // Проверяем пересечение
                if (newStart < existingEnd && newEnd > existingStart) {
                    row.classList.add('overlapping-event');
                }
            });
        }
        
        // Функция сброса подсветки
        function resetHighlight() {
            const rows = document.querySelectorAll('#eventsBody tr[id^="event-"]');
            rows.forEach(row => {
                row.classList.remove('overlapping-event');
            });
        }
        
        // Функция сортировки событий
        function sortEvents() {
            const tbody = document.getElementById('eventsBody');
            const rows = Array.from(tbody.querySelectorAll('tr[id^="event-"]'));
            
            if (rows.length === 0) return;
            
            // Сортируем строки таблицы
            rows.sort((a, b) => {
                const aCells = a.querySelectorAll('td');
                const bCells = b.querySelectorAll('td');
                
                let aValue, bValue;
                
                // Выбираем значение для сортировки в зависимости от колонки
                if (currentSortColumn === 'start') {
                    // Сортировка по времени начала
                    aValue = parseTableTime(aCells[2].textContent);
                    bValue = parseTableTime(bCells[2].textContent);
                } else if (currentSortColumn === 'end') {
                    // Сортировка по времени окончания
                    aValue = parseTableTime(aCells[3].textContent);
                    bValue = parseTableTime(bCells[3].textContent);
                } else if (currentSortColumn === 'name') {
                    // Сортировка по названию
                    aValue = aCells[1].textContent.toLowerCase();
                    bValue = bCells[1].textContent.toLowerCase();
                } else if (currentSortColumn === 'id') {
                    // Сортировка по ID
                    aValue = parseInt(aCells[0].textContent);
                    bValue = parseInt(bCells[0].textContent);
                }
                
                // Сравниваем значения
                if (aValue < bValue) {
                    return currentSortDirection === 'asc' ? -1 : 1;
                } else if (aValue > bValue) {
                    return currentSortDirection === 'asc' ? 1 : -1;
                }
                return 0;
            });
            
            // Удаляем все строки из таблицы
            rows.forEach(row => tbody.removeChild(row));
            
            // Добавляем отсортированные строки обратно
            rows.forEach(row => tbody.appendChild(row));
            
            // Обновляем индикаторы сортировки
            updateSortIndicators();
        }
        
        // Функция обновления индикаторов сортировки
        function updateSortIndicators() {
            // Сбрасываем все индикаторы
            document.querySelectorAll('.sortable').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });
            
            // Устанавливаем индикатор для текущей колонки
            const sortHeader = document.getElementById(`sort${currentSortColumn.charAt(0).toUpperCase() + currentSortColumn.slice(1)}`);
            if (sortHeader) {
                if (currentSortDirection === 'asc') {
                    sortHeader.classList.add('sorted-asc');
                } else {
                    sortHeader.classList.add('sorted-desc');
                }
            }
        }
        
        // Функция обработки клика по заголовку для сортировки
        function setupSorting() {
            document.querySelectorAll('.sortable').forEach(th => {
                th.addEventListener('click', function() {
                    const sortType = this.getAttribute('data-sort');
                    
                    // Если кликнули по той же колонке, меняем направление сортировки
                    if (currentSortColumn === sortType) {
                        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        // Иначе сортируем по новой колонке по возрастанию
                        currentSortColumn = sortType;
                        currentSortDirection = 'asc';
                    }
                    
                    // Обновляем атрибут направления в элементе
                    this.setAttribute('data-direction', currentSortDirection);
                    
                    // Выполняем сортировку
                    sortEvents();
                });
            });
        }
        
        // Функция сортировки при загрузке данных
        function sortOnLoad() {
            // Инициализируем данные событий из таблицы
            const rows = document.querySelectorAll('#eventsBody tr[id^="event-"]');
            eventsData = Array.from(rows).map(row => {
                const cells = row.querySelectorAll('td');
                return {
                    id: row.id.replace('event-', ''),
                    cells: Array.from(cells).map(cell => cell.innerHTML)
                };
            });
            
            // Сортируем по умолчанию по времени начала (по возрастанию)
            sortEvents();
        }
        
        function setDefaultTimes() {
            const now = new Date();
            const startTimeInput = document.getElementById('actualStartTime');
            const endTimeInput = document.getElementById('actualEndTime');
            
            const formatDateTime = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                
                return `${year}-${month}-${day}T${hours}:${minutes}`;
            };
            
            if (!startTimeInput.value) {
                startTimeInput.value = formatDateTime(now);
            }
            
            if (!endTimeInput.value) {
                const endTime = new Date(now);
                endTime.setHours(endTime.getHours() + 1);
                endTimeInput.value = formatDateTime(endTime);
            }
            
            // Сброс подсветки при установке времени по умолчанию
            resetHighlight();
        }
        
        function saveEvent() {
            const batchId = document.getElementById('batchId').value;
            const eventNameInput = document.getElementById('eventName');
            const startTimeInput = document.getElementById('actualStartTime');
            const endTimeInput = document.getElementById('actualEndTime');
            const timeGroupSelect = document.getElementById('timeGroup');
            
            const eventName = eventNameInput.value.trim();
            const actualStartTime = startTimeInput.value;
            const actualEndTime = endTimeInput.value;
            const timeGroup = timeGroupSelect.value;
            const messageDiv = document.getElementById('message');
            
            // Сброс подсветки перед проверкой
            resetHighlight();
            
            // Валидация заполнения полей
            if (!eventName) {
                showMessage('Введите название события', 'error');
                eventNameInput.focus();
                return;
            }
            
            if (!actualStartTime) {
                showMessage('Введите время начала события', 'error');
                startTimeInput.focus();
                return;
            }
            
            if (!actualEndTime) {
                showMessage('Введите время окончания события', 'error');
                endTimeInput.focus();
                return;
            }
            
            if (!timeGroup) {
                showMessage('Выберите группу времени', 'error');
                timeGroupSelect.focus();
                return;
            }
            
            const startTime = new Date(actualStartTime);
            const endTime = new Date(actualEndTime);
            
            // Проверка корректности временного интервала
            if (endTime <= startTime) {
                showMessage('Время окончания должно быть позже времени начала', 'error');
                endTimeInput.focus();
                return;
            }
            
            // ПРОВЕРКА: Время события должно быть в пределах ±3 часа от планового времени батча
            const timeBoundsCheck = checkEventTimeBounds(startTime, endTime);
            if (!timeBoundsCheck.isValid) {
                showMessage(timeBoundsCheck.message, 'error');
                return;
            }
            
            // Проверка на пересечение с существующими событиями
            const overlapCheck = checkTimeOverlap(startTime, endTime);
            if (overlapCheck.hasOverlap) {
                showMessage(`Ошибка: временной интервал пересекается с событием "${overlapCheck.overlappingEventName}"`, 'error');
                // Подсвечиваем пересекающееся событие
                highlightOverlappingEvents(startTime, endTime);
                return;
            }
            
            // Подготовка данных для отправки
            const data = {
                batch_id: batchId,
                event_name: eventName,
                actual_start_time: actualStartTime,
                actual_end_time: actualEndTime,
                time_group: timeGroup
            };
            
            // Отправка данных на сервер
            fetch('/save_event', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message, 'success');
                    // Очистка формы
                    eventNameInput.value = '';
                    setDefaultTimes();
                    timeGroupSelect.value = '';
                    // Обновление таблицы
                    updateEventsTable(data.events);
                    // Сброс подсветки
                    resetHighlight();
                } else {
                    // Если сервер вернул ошибку о пересечении
                    if (data.error && data.error.includes('пересекается')) {
                        highlightOverlappingEvents(startTime, endTime);
                    }
                    showMessage('Ошибка: ' + data.error, 'error');
                }
            })
            .catch(error => {
                showMessage('Ошибка соединения: ' + error, 'error');
                console.error('Error:', error);
            });
        }
        
        function deleteEvent(eventId) {
            if (!confirm('Вы уверены, что хотите удалить это событие?')) {
                return;
            }
            
            fetch(`/delete_event/${eventId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showMessage(data.message, 'success');
                    updateEventsTable(data.events);
                    // Сброс подсветки после удаления
                    resetHighlight();
                } else {
                    showMessage('Ошибка: ' + data.error, 'error');
                }
            })
            .catch(error => {
                showMessage('Ошибка соединения: ' + error, 'error');
                console.error('Error:', error);
            });
        }
        
        function updateEventsTable(events) {
            const tbody = document.getElementById('eventsBody');
            tbody.innerHTML = '';
            
            if (events.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 6;
                cell.textContent = 'Нет событий для этого батча';
                cell.style.textAlign = 'center';
                cell.style.color = '#999';
                cell.style.padding = '20px';
                row.appendChild(cell);
                tbody.appendChild(row);
                // Обновляем индикаторы сортировки
                updateSortIndicators();
                return;
            }
            
            events.forEach(event => {
                const row = document.createElement('tr');
                row.id = `event-${event.event_id}`;
                
                const idCell = document.createElement('td');
                idCell.textContent = event.event_id;
                row.appendChild(idCell);
                
                const nameCell = document.createElement('td');
                nameCell.textContent = event.event_name;
                row.appendChild(nameCell);
                
                const startCell = document.createElement('td');
                startCell.textContent = event.actual_start_time;
                startCell.setAttribute('data-sort-value', event.actual_start_time);
                row.appendChild(startCell);
                
                const endCell = document.createElement('td');
                endCell.textContent = event.actual_end_time;
                row.appendChild(endCell);
                
                const timeGroupCell = document.createElement('td');
                const badge = document.createElement('span');
                badge.className = 'time-group-badge ';
                
                if (event.time_group === 'Planned pause time') {
                    badge.className += 'planned-pause';
                } else if (event.time_group === 'Utilization hours') {
                    badge.className += 'utilization';
                } else if (event.time_group === 'Breakdown time') {
                    badge.className += 'breakdown';
                }
                
                badge.textContent = event.time_group;
                timeGroupCell.appendChild(badge);
                row.appendChild(timeGroupCell);
                
                const actionsCell = document.createElement('td');
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-btn';
                deleteButton.textContent = 'Удалить';
                deleteButton.onclick = function() {
                    deleteEvent(event.event_id);
                };
                actionsCell.appendChild(deleteButton);
                row.appendChild(actionsCell);
                
                tbody.appendChild(row);
            });
            
            // После обновления таблицы применяем текущую сортировку
            sortEvents();
        }
        
        function showMessage(text, type) {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = text;
            messageDiv.className = `message ${type}`;
            messageDiv.style.display = 'block';
            
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 5000);
        }
        
        // Обработчики событий для проверки пересечений в реальном времени
        function setupRealTimeValidation() {
            const startTimeInput = document.getElementById('actualStartTime');
            const endTimeInput = document.getElementById('actualEndTime');
            
            function validateTimeInputs() {
                const startValue = startTimeInput.value;
                const endValue = endTimeInput.value;
                
                if (!startValue || !endValue) {
                    resetHighlight();
                    return;
                }
                
                const startTime = new Date(startValue);
                const endTime = new Date(endValue);
                
                if (endTime > startTime) {
                    highlightOverlappingEvents(startTime, endTime);
                } else {
                    resetHighlight();
                }
            }
            
            startTimeInput.addEventListener('change', validateTimeInputs);
            endTimeInput.addEventListener('change', validateTimeInputs);
            startTimeInput.addEventListener('input', validateTimeInputs);
            endTimeInput.addEventListener('input', validateTimeInputs);
        }
        
        // Обработчики для сохранения по Enter
        const inputs = document.querySelectorAll('.form-container input, .form-container select');
        inputs.forEach(input => {
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    saveEvent();
                }
            });
        });
        
        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            // Инициализируем временные границы батча
            initBatchTimeBounds();
            
            setDefaultTimes();
            setupRealTimeValidation();
            setupSorting();
            sortOnLoad();
        });
    </script>
</body>
</html>